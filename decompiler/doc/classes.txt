Data flow
=========

Script data is first passed into a _Parser_ instance, which produces
a stream of _Instructions_. This list is then passed to _Control Flow Graph_,
which uses it to build a graph comprised of _Nodes_. We ask _Control Flow
Graph_ to perform a number of analyses, and finally use the information
filled in by it to traverse the graph starting from the entry point and
rebuild the abstract syntax tree.


Classes
=======

Instruction
-----------

Represents a logical instruction of the original script in a unified way.
Contains opcode's address (offset of the original opcode in the input byte
stream) and a textual description.


### Jump

A conditional or unconditional jump. In addition to information contained by
its superclass _Instruction_, it also contains jump target - address of the
_Instruction_ to which the control is transferred.

#### CondJump

Unconditional jump. By convention, these are only "jump if not" instructions,
so the other types of conditional jumps need to be normalized to this form.



Script
------

A sequence of _Instructions_, and a sink for a _Parser_ instance. To be
removed in favor of using a simple collection.



Parser
------

Given a byte source (currently file/filename), its task is to produce
an intermediate _Instruction_ stream. As of now, the _Instructions_ are
appended into a _Script_. A _Parser_ typically uses a number of helper
_Reader_ instances.


### Scumm6Parser



Reader
------

A _Reader_ is responsible for producing a single Instruction, typically
it will consume a few bytes from the input byte stream. It will either
produce an Instruction, or sometimes delegate the task to another
_Reader_. Currently, a number of _Reader_ subclasses exist:


### SimpleReader

Produces an _Instruction_. It accepts a format string in its constructor,
which describes type and number of immediate arguments of the _Instruction_.
The bytes corresponding to these inlined script arguments will be consumed
from the input stream. Currently, the following argument types are supported:

* b - byte
* w - unsigned word (2 bytes)
* W - signed word
* o - jump offset (signed word)
* s - SCUMM string


### JumpReader and CondJumpReader

These are specialized _SimpleReaders_ that emit a _Jump_ or _CondJump_
instruction, instead of a regular _Instruction_.


### SubopcodeReader

A compound _Reader_, which delegates the work to previously registered
_Readers_, after consuming a single byte to make the decision on which
child _Reader_ to use.


### SeqReader

This reader calls two readers in sequence. Typically used to add two or more
_Instructions_ to the output stream, using _SimpleReaders_ as children.



ControlFlowGraph
----------------

Represents Control Flow Graph of the original script. It needs to be
initialized by first giving it a stream of _Instructions_, and then
setting an entry point. It has 3 main methods that are used to perform
consecutive stages of code structuring

* structureLoops
* structureConditionals
* structureSequences (not implemented)

Most of these methods collapse a subgraph into a single node as a result,
and append the corresponding subgraph to a list of subgraphs - for the
ease of calling next restructuring stages on them.



Node
----

The basic element of a _Control Flow Graph_. Contains a list of
_Instructions_, and in/out edges to other _Nodes_. By convention,
if the node ends with a conditional jump, the first edge corsesponds
to the branch taken if the test condition is false ("jump if not").

It has the following subclasses:


### BasicBlock

Holds a list of primitive instructions.


### ProxyNode

Contains a single reference to a node in a different graph, and by convention
never has any outgoing edges. As of now it is used in two situations

* interval analysis, to build the Derived Sequence of Graphs
* yanking out subgraphs when collapsing loops and conditionals - each
  out edge crossing the graph boundary is replaced with an edge to
  a _ProxyNode_


### Loop

Contains the loop body (a subgraph) and optionally an exit condition.
The constructor of each of the subclasses links the collapsed node
back to the original graph, and recursively performs the loop
structuring on the obtained subgraph.


#### WhileLoop

#### DoWhileLoop

#### EndlessLoop


### IfThenElse

Contains two conditional branches (subgraphs).
